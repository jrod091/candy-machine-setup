#!/usr/bin/env bash
#######################################################################
# Candy-Machine Deploy Script                                         #
# ------------------------------------------------------------------- #
# Author: jrod091                                                     #
# Copyright jrod091, 2021                                             #
#                                                                     #
# Description:                                                        #
# This script sets up a metaplex store and candy machine for batch    #
# minting from scratch.                                               #
#######################################################################

if [ `whoami` = root ]; then # exit if running as root
   echo "${red}Script cannot be run as root!${normal}"
   exit 1
fi

## SET COLORS IF TERMINAL SUPPORTS IT
if test -t 1; then # if terminal
   ncolors=$(which tput > /dev/null && tput colors) # supports color
   if test -n "$ncolors" && test $ncolors -ge 8; then
      termcols=$(tput cols)
      bold="$(tput bold)"
      underline="$(tput smul)"
      standout="$(tput smso)"
      normal="$(tput sgr0)"
      black="$(tput setaf 0)"
      red="$(tput setaf 1)"
      green="$(tput setaf 2)"
      yellow="$(tput setaf 3)"
      blue="$(tput setaf 4)"
      magenta="$(tput setaf 5)"
      cyan="$(tput setaf 6)"
      white="$(tput setaf 7)"
      orange="$(tput setaf 166)"
   fi
fi

## VARIABLES
network=''
pubkey=''
current_dir=''
metaplex_dir=''
assets_dir=''
js_dir=''
cm_cli=''
cmm_dir=''
env_ex_file=''
env_file=''
num_imgs=''

## FUNCTIONS
help_print() { # print help text
   cat <<EOF
Usage: candy_machine_setup <[options]>

Options:
   -d, --devnet            set 'devnet' as network
   -h, --help              print command line options
   -m, --mainnet           set 'mainnet' as network
   -n, --newwallet         setup new wallet locally
   -w {ID}, --wallet={ID}  set public wallet key address from Phantom or other source
EOF
}

success_print() { # success print
   echo "${green}${*}${normal}"
}

warn_print() { # warning print
   echo "${orange}${*}${normal}"
}

err_print() { # error print
   echo "${red}${*}${normal}"
}

success_printf() { # printf implementation of success print
   spacer="$1"
   output="$2"
   printf "${green}%$((${COLUMNS} - ${#spacer}))s\n${normal}" "${output}"
}

warn_printf() { # printf impementation of warning print
   output="$1"
   printf "${orange}%s${normal}" "${output}"
}

err_printf() { # printf impementation of error print
   spacer="$1"
   output="$2"
   printf "${red}%$((${COLUMNS} - ${#spacer}))s\n${normal}" "${output}"
}

shutdown() { # reset cursor in case spinner command errors out
    tput cnorm # reset cursor
}
trap shutdown EXIT

cursorBack() { # move cursor back for spinner animation
    echo -en "\033[$1D"
}

spinner() { # spiner animation so user doesn't think script is hung
    local LC_TYPE=C
    local info="$1"
    local pid=$!
    local delay=0.1
    local spin='⣾⣽⣻⢿⡿⣟⣯⣷'
    #local spin='◐◓◑◒'
    local charwidth=1
    printf "$info"

    local i=0
    tput civis # invisible cursor

    while kill -0 $pid 2> /dev/null; do
	    local i=$(((i + $charwidth) % ${#spin}))
	    printf "${cyan}%s${normal}" "${spin:$i:$charwidth}"
	    
        cursorBack $charwidth
	    sleep $delay
    done

    tput cnorm
    wait $pid
    return $?
}

check_cmd() { # check if command failed
   if [ $1 -ne 0 ]; then
      err_printf "$2" "$3"
      exit 13
   fi
}

bad_opt() { # print error to STDOUT and exit with error code '2'
   echo "${red}$*${normal}" >&2
   help_print
   exit 2
}

need_arg() { # flag that no argument was passed with long flag
   if [ -z "$OPTARG" ]; then
      bad_opt "${red}No argument for --$OPT given!${normal}"
      help_print
   fi
}

check_npm_installed() { # check if specified npm package is installed
   echo "Checking to see if [$1] is installed..."
   npm list -g | grep -q $1
}

install_npm_pkg() { # install npm package quietly
   warn_printf "[$1] not found, installing..."
   sudo npm install -g $1 &>/dev/null
   check_cmd $? "[$1] not found, installing..." "[failed to install $1]"
   success_printf "[$1] not found, installing..." "[$1] installed successfully"
}

check_installed() { # check if package is installed
   printf "Checking to see if [$1] is installed..."
   apt -qq list $1 2>/dev/null | grep -qE "(installed|upgradable)"
}

install_pkg() { # install package quietly
   warn_printf "[$1] not found, installing..."
   sudo apt-get update -qq
   sudo DEBIAN_FRONTEND=noninteractive apt-get install -qq $1 &>/dev/null
   check_cmd $? "[$1] not found, installing..." "[failed to install $1]"
   success_printf "[$1] not found, installing..." "[$1] installed successfully"
}

string_contains() { # check if substring ($1) in string ($2), case insensitve search
   local _lc=${2,,}
   [ -z "$1" ] || { [ -z "${_lc##*${1,,}*}" ] && [ -n "$2" ] ;} ;
}

## USER INPUT
while getopts ":dhmnw:-:" OPT; do
   if [ "$OPT" = "-" ]; then  # long option support
      OPT="${OPTARG%%=*}"     # extract long option name
      OPTARG="${OPTARG#$OPT}" # extract long option argument (may be empty)
      OPTARG="${OPTARG#=}"    # if long option argument, remove assigning '='
   fi

   case "$OPT" in
      d | devnet )      network='devnet' ;;                 # set devnet
      h | help )        help_print; exit 0 ;;               # print help
      m | mainnet )     network='mainnet-beta' ;;           # set mainnet
      n | newwallet )   pubkey='new' ;;                     # generate new wallet
      w | wallet )      pubkey="${OPTARG}" ;;               # set public wallet key address
      ??* )             bad_opt "Unknown option --$OPT" ;;  # bad long option
      ? )               bad_opt ;;                          # bad short option
   esac
done
shift $((OPTIND-1)) # remove parsed options and args from $@ list

## CHECK REQUIRED FLAGS
if [ "${network}" = "" ]; then
   err_print "Fatal: Solana network not set!"
   warn_print "Pass the [-d] flag for devnet or the [-m] flag for mainnet"
   help_print
   exit 3
fi

if [ "${pubkey}" = "" ]; then
   err_print "Fatal: Wallet address required!"
   warn_print "Pass the [-n] flag to create a new wallet or the [-w] flag followed by your wallet address"
   help_print
   exit 4
fi

## MAIN SCRIPT
current_dir=$(pwd) # save current working directory
log_file="${current_dir}/candy_machine_setup_error.log"
# check if 'nodejs' is setup, install if not
current_display="Checking to see if [nodejs] is installed..."
printf "${current_display}"
if node --version &>/dev/null; then
   success_printf "${current_display}" "[nodejs found]"
else
   printf "\n"
   if check_installed curl; then
      success_printf "Checking to see if [curl] is installed..." "[curl] found."
   else
      install_pkg curl
   fi

   curl -fsSL https://deb.nodesource.com/setup_16.x | sudo -E bash -

   # install pre-requisites
   if check_installed gcc; then
      success_printf "Checking to see if [gcc] is isntalled..." "[gcc] found."
   else
      install_pkg gcc
   fi

   if check_installed g++; then
      success_printf "Checking to see if [g++] is isntalled..." "[g++] found."
   else
      install_pkg g++
   fi

   if check_installed make; then
      success_printf "Checking to see if [make] is isntalled..." "[make] found."
   else
      install_pkg make
   fi
   
   install_pkg nodejs
fi

# check if 'yarn' is installed, install if not
if check_npm_installed yarn; then
   success_printf "Checking to see if [yarn] is isntalled..." "[yarn] found."
else
   install_npm_pkg yarn
fi

# check if 'git' is installed, install if not
if check_installed git; then
   success_printf "Checking to see if [git] is isntalled..." "[git] found."
else
   install_pkg git
fi

# clone metaplex repo
if [ ! -d "${current_dir}/metaplex" ]; then # only clone if not already existing
   printf "cloning [metaplex] repo..."
   git clone https://github.com/metaplex-foundation/metaplex.git &>/dev/null
   check_cmd $? "cloning [metaplex] repo..." "failed to clone [metaplex] repo."
   success_printf "cloning [metaplex] repo..." "[metaplex] repo cloned successfully."
fi

# check if 'ts-node' installed, install if not
if check_npm_installed ts-node; then
   success_printf "Checking to see if [ts-node] is isntalled..." "[ts-node] found."
else
   install_npm_pkg ts-node
fi

# check if solana is installed, install if not
echo "Checking to see if [solana] installed..."
if solana --version &>/dev/null; then
   success_printf "Checking to see if [solana] is isntalled..." "[solana] found."
else
   warn_print "[solana] not found, installing..."
   sh -c "$(curl -sSfL https://release.solana.com/v1.8.0/install)"
   check_cmd $? "[solana] not found, installing..." "failed to install [solana]"
   . ~/.profile # source .profile so PATH updates in current session
   success_printf "[solana] not found, installing..." "[solana] installed successfully."
fi

solana config set --url https://api.${network}.solana.com >/dev/null # set solana network
check_cmd $?
keyJSON="${HOME}/.config/solana/wallet.json"

if [ ! -f $keyJSON ]; then # only if keypair doesn't exist
   if [ "${pubkey}" = "new" ]; then # generate new wallet
      solana-keygen new --outfile $keyJSON > tmp.txt
      check_cmd $?

      pubkey=$(cat tmp.txt | grep pubkey | cut -d' ' -f2)
      passphrase=$(cat tmp.txt | grep -A 1 recover | grep -v recover)

      rm -f tmp.txt # remove file so seed phrase is not saved on system
      echo "Save this seed phrase and your BIP39 passphrase to recover your new keypair: [${passphrase}]."
      read -r -s -N 1 -p "Press [Enter] to continue..."
   else  #import public wallet
      echo "${orange}Note: You will need your recovery phrase to import wallet. This is required by Solana CLI and will not be saved by this script nor on the system anywhere. The input is silent as well so no one can see the input as you type it in or copy it!${normal}"
      solana-keygen recover 'prompt://?key=0/0' --outfile $keyJSON
      check_cmd $? "" "failed to import wallet."
   fi
fi

solana config set --keypair $keyJSON >/dev/null # set Solana CLI to use wallet
check_cmd $?
success_print "set keypair successfully."

if [ "${network}" = "devnet" ]; then # only airdrop if running on devnet
   solana airdrop 1 >/dev/null #airdrop some SOL
   check_cmd $? "" "airdrop to wallet failed."
   success_print "airdropped 1 SOL."
fi

metaplex_dir="${current_dir}/metaplex"
assets_dir="${current_dir}/assets"

if [ ! -d $assets_dir ]; then # only if directory doesn't exist
   printf "Creating directory for images..."
   mkdir $assets_dir &>/dev/null # create directory for assests
   check_cmd "Creating directory for images..." "failed to create [$assets_dir}]."
   success_printf "Creating directory for images..." "Directory [${assets_dir}] created successfully."
fi

js_dir="${metaplex_dir}/js"
cd $js_dir

echo "" # just adding an extra break in output
echo "Installing node modules..."
yarn install --silent 2>${log_file} # install required npm modules
check_cmd $? "Installing node modules..." "failed to install node modules."
success_printf "Installing node moudles..." "Node modules installed successfully."

echo "${orange}********************************************************************************************************************************************
Pausing to allow time to upload images and JSON files to [${assets_dir}]. Refer to the README for further
information on properly setting up your images and JSON files.
}*******************************************************************************************************************************************${normal}"
read -r -s -N 1 -p "Press [Enter] to continue..." key

cd ${current_dir} # go back to starting location to save mint cache there
cm_cli="${js_dir}/packages/cli/src/candy-machine-cli.ts"

printf "Uploading images for candy machine..."
ts-node $cm_cli upload $assets_dir --env ${network} --keypair ${keyJSON} 2>${log_file} 1>/dev/null
check_cmd $? "Uploading images for candy machine..." "failed to upload images."
success_printf "Uploading images for candy machine..." "Image upload successful."

sol_price=$(curl https://www.coingecko.com/en/coins/solana 2>/dev/null | grep -oP '(?<=<span class="no-wrap" data-price-btc).*?(?=</span>)' | sed 's/[^>]*>//g' | sed -n '1p')

read -p "What would you like the price of the NFTs to be (in SOL [1 SOL currently ${sol_price} USD]): " price

printf "Creating candy machine..."
ts-node $cm_cli create_candy_machine --env ${network} --keypair ${keyJSON} --price ${price} 2>${log_file} 1>/dev/null
check_cmd $? "Creating candy machine..." "failed to create candy machine."
success_printf "Creating candy machine..." "Candy machine created successfully."

start_of_today=`date '+%d %b %Y 00:00:00 %Z'`
printf "Updating candy machine with available minting start date to [${start_of_today}]..."
ts-node $cm_cli update_candy_machine --env ${network} --keypair ${keyJSON} --date "${start_of_today}" 2>${log_file} 1>/dev/null
check_cmd $? "Updating candy machine with available minting start date to [${start_of_today}]..." "failed to update candy machine."
success_printf "Updating candy machine with available minting start date to [${start_of_today}]..." "Date updated successfully."

num_imgs=$(ls ${assests_dir}/*.png | wc -l) # get number of images in assets directory
count=0 # used in progress print

for i in $(seq $num_images); do # mint images, one at a time
   printf "\rMinting operation ongoing... successfully minted [${count}] of [${num_imgs}]"
   ts-node $cm_cli mint_one_token -e ${network} -k ${keyJSON} 2>${log_file} 1>/dev/null
   check_cmd $? "Minting operation ongoing... successfully minted [${count}] of [${num_imgs}]" "unable to mint image."
   count=$((count+1))
done
success_print "\r[${count}] images successfully minted."

exit 0 # normal exit